name: Python Code Analysis

on:
  push:
    branches:
      - master
  pull_request_target:
    branches:
      - master
    types: [opened, synchronize, reopened]
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  code-analysis:
    if: github.event_name != 'pull_request_target' || github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.9', '3.10', '3.11', '3.12', '3.13', '3.14']

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.pull_request.head.sha || github.sha }}

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}

    - name: Cache pip dependencies
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        # Install code analysis tools
        pip install pyright bandit vulture pycodestyle autopep8 ruff==0.14.13

    - name: Deprecation Warnings Scan
      continue-on-error: true
      run: |
        python - <<'PY'
        import re
        import warnings
        from pathlib import Path
        import importlib.util

        warnings.simplefilter('default', DeprecationWarning)
        warnings.simplefilter('default', PendingDeprecationWarning)

        captured = []

        def record_warning(message, category, filename, lineno, file=None, line=None):
            captured.append(f"{category.__name__}: {message} ({filename}:{lineno})")

        warnings.showwarning = record_warning

        exclude_dirs = {'.git', '__pycache__', '.pytest_cache', 'venv', '.venv', 'env', 'tmp', 'tests', 'bin'}
        roots = [Path('src'), Path('web_ui'), Path('cogs')]
        files = []

        for root in roots:
            if root.exists():
                for path in root.rglob('*.py'):
                    if not any(part in exclude_dirs for part in path.parts):
                        files.append(path)

        files.extend([p for p in Path('.').glob('*.py') if p.is_file()])

        def module_name_from_path(path: Path) -> str:
            sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', path.as_posix())
            return f"deprecation_scan_{sanitized}"

        for path in sorted(set(files)):
            try:
                spec = importlib.util.spec_from_file_location(module_name_from_path(path), path)
                if spec and spec.loader:
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)
            except Exception:
                # Ignore import/runtime errors during deprecation scanning
                continue

        with open('deprecation-warnings.txt', 'w', encoding='utf-8') as f:
            if captured:
                f.write('\n'.join(captured))
        PY

    - name: Ruff Lint
      continue-on-error: true
      run: |
        echo "Ruff version:"
        ruff --version
        echo "Checking for pyproject.toml:"
        ls -la pyproject.toml
        echo "Running ruff check:"
        ruff check --config pyproject.toml . > ruff-results-${{ matrix.python-version }}.txt 2>&1
        cat ruff-results-${{ matrix.python-version }}.txt

    - name: Upload Deprecation Warnings
      if: github.event_name == 'pull_request_target'
      uses: actions/upload-artifact@v4
      with:
        name: deprecation-warnings-${{ matrix.python-version }}
        path: deprecation-warnings.txt

    - name: Upload Ruff Results
      if: github.event_name == 'pull_request_target'
      uses: actions/upload-artifact@v4
      with:
        name: ruff-results-${{ matrix.python-version }}
        path: ruff-results-${{ matrix.python-version }}.txt

    - name: Type Checking with Pyright
      continue-on-error: true
      run: |
        echo "Running type checking for Python ${{ matrix.python-version }}..."
        # Override pythonVersion in Pyright to match the matrix version
        pyright --pythonversion ${{ matrix.python-version }} . > pyright-results-${{ matrix.python-version }}.txt 2>&1 || echo "Pyright scan completed with results saved"
        
        # Display results
        cat pyright-results-${{ matrix.python-version }}.txt

    - name: Upload Pyright Results
      if: github.event_name == 'pull_request_target'
      uses: actions/upload-artifact@v4
      with:
        name: pyright-results-${{ matrix.python-version }}
        path: pyright-results-${{ matrix.python-version }}.txt

    - name: Security Analysis with Bandit
      continue-on-error: true
      run: |
        echo "Running security analysis with configuration file..."
        echo ""
        echo "üîí SECURITY NOTE: tmp directory security is handled at application level:"
        echo "   ‚úÖ tmp directories created with 0o700 permissions (owner-only access)"
        echo "   ‚úÖ Implemented in upload.py do_the_thing() function"
        echo "   ‚úÖ Bandit B108 warnings suppressed via bandit.yaml config file"
        echo ""
        echo "üìä Using bandit.yaml configuration file to skip resolved security issues"
        
        # Check if bandit.yaml config file exists and use it
        if [ -f "bandit.yaml" ]; then
          echo "‚úÖ Found bandit.yaml configuration file"
          cat bandit.yaml
          echo ""
          echo "Running bandit with YAML configuration..."
          bandit -r . -f txt -c bandit.yaml > bandit-results.txt 2>&1 || echo "Bandit scan completed with configuration"
        elif [ -f ".bandit" ]; then
          echo "‚úÖ Found legacy .bandit configuration file"
          cat .bandit
          echo ""
          echo "Running bandit with legacy configuration..."
          bandit -r . -f txt -c .bandit > bandit-results.txt 2>&1 || echo "Bandit scan completed with configuration"
        else
          echo "‚ö†Ô∏è  No bandit config file found, running with basic exclusions"
          bandit -r . -f txt --exclude ./tmp,./venv,./.venv,./env,./.git,./__pycache__ > bandit-results.txt 2>&1 || echo "Bandit scan completed"
        fi
        
        # Display results
        cat bandit-results.txt

    - name: Upload Bandit Results
      if: github.event_name == 'pull_request_target'
      uses: actions/upload-artifact@v4
      with:
        name: bandit-results-${{ matrix.python-version }}
        path: bandit-results.txt

    - name: Dependency Security Check with Safety
      continue-on-error: true
      run: |
        echo "Running dependency security check with Safety..."
        pip install safety
        safety check > safety-results.txt 2>&1 || echo "Safety scan completed with results saved"
        
        # Display results
        cat safety-results.txt

    - name: Upload Safety Results
      if: github.event_name == 'pull_request_target'
      uses: actions/upload-artifact@v4
      with:
        name: safety-results-${{ matrix.python-version }}
        path: safety-results.txt

    - name: Dead Code Analysis
      continue-on-error: true
      run: |
        echo "Checking for unused code..."
        vulture . --exclude=venv,env,.venv,.git --min-confidence=80 > vulture-results.txt 2>&1 || echo "Vulture analysis completed"
        
        # Display results
        cat vulture-results.txt

    - name: Upload Vulture Results
      if: github.event_name == 'pull_request_target'
      uses: actions/upload-artifact@v4
      with:
        name: vulture-results-${{ matrix.python-version }}
        path: vulture-results.txt

  summary:
    runs-on: ubuntu-latest
    needs: code-analysis
    if: always()
    
    steps:
    - name: Analysis Summary
      run: |
        echo "Python Code Analysis Summary:"
        echo "‚úÖ Ruff lint completed"
        echo "‚úÖ Deprecation warnings scan completed"
        echo "‚úÖ Type checking completed"
        echo "‚úÖ Security analysis with Bandit completed"
        echo "‚úÖ Dependency security check with Safety completed"
        echo "‚úÖ Dead code analysis completed"
        echo "‚úÖ Common issues check completed"
        echo ""
        echo "Check the job logs above for detailed results."

  pr-comment:
    if: github.event_name == 'pull_request_target' && github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    needs: code-analysis
    permissions:
      contents: read
      issues: write
      pull-requests: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download Bandit Results
      uses: actions/download-artifact@v4
      with:
        pattern: bandit-results-*
        merge-multiple: true
        
    - name: Download Vulture Results
      uses: actions/download-artifact@v4
      with:
        pattern: vulture-results-*
        merge-multiple: true
        
    - name: Download Safety Results
      uses: actions/download-artifact@v4
      with:
        pattern: safety-results-*
        merge-multiple: true
        
    - name: Download Pyright Results
      uses: actions/download-artifact@v4
      with:
        pattern: pyright-results-*
        merge-multiple: true

    - name: Download Ruff Results
      uses: actions/download-artifact@v4
      with:
        pattern: ruff-results-*
        merge-multiple: true

    - name: Download Deprecation Warnings
      uses: actions/download-artifact@v4
      with:
        pattern: deprecation-warnings-*
        merge-multiple: true
        
    - name: Post Bandit Results to PR
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const path = require('path');
          
          // Check for merged bandit-results.txt file
          const banditFile = 'bandit-results.txt';
          let banditResults = '';
          
          if (fs.existsSync(banditFile)) {
            try {
              banditResults = fs.readFileSync(banditFile, 'utf8');
              console.log('Found merged Bandit results file');
            } catch (error) {
              console.log(`Error reading Bandit file: ${error.message}`);
            }
          } else {
            // Fallback: look for individual result directories
            console.log('Merged Bandit file not found, checking individual directories...');
            const items = fs.readdirSync('.').filter(item => item.startsWith('bandit-results-'));
            
            for (const item of items) {
              try {
                const itemPath = path.join('.', item);
                const stat = fs.statSync(itemPath);
                
                if (stat.isDirectory()) {
                  const filePath = path.join(itemPath, 'bandit-results.txt');
                  if (fs.existsSync(filePath)) {
                    const content = fs.readFileSync(filePath, 'utf8');
                    if (content.trim()) {
                      banditResults += content + '\n\n';
                      console.log(`Found Bandit results in ${item}`);
                    }
                  }
                } else if (stat.isFile() && item.endsWith('.txt')) {
                  const content = fs.readFileSync(itemPath, 'utf8');
                  if (content.trim()) {
                    banditResults += content + '\n\n';
                    console.log(`Found Bandit results in ${item}`);
                  }
                }
              } catch (error) {
                console.log(`Error reading Bandit ${item}: ${error.message}`);
              }
            }
          }
          
          // Check for merged vulture-results.txt file
          const vultureFile = 'vulture-results.txt';
          let vultureResults = '';
          
          if (fs.existsSync(vultureFile)) {
            try {
              vultureResults = fs.readFileSync(vultureFile, 'utf8');
              console.log('Found merged Vulture results file');
            } catch (error) {
              console.log(`Error reading Vulture file: ${error.message}`);
            }
          } else {
            // Fallback: look for individual result directories
            console.log('Merged Vulture file not found, checking individual directories...');
            const items = fs.readdirSync('.').filter(item => item.startsWith('vulture-results-'));
            
            for (const item of items) {
              try {
                const itemPath = path.join('.', item);
                const stat = fs.statSync(itemPath);
                
                if (stat.isDirectory()) {
                  const filePath = path.join(itemPath, 'vulture-results.txt');
                  if (fs.existsSync(filePath)) {
                    const content = fs.readFileSync(filePath, 'utf8');
                    if (content.trim()) {
                      vultureResults += content + '\n\n';
                      console.log(`Found Vulture results in ${item}`);
                    }
                  }
                } else if (stat.isFile() && item.endsWith('.txt')) {
                  const content = fs.readFileSync(itemPath, 'utf8');
                  if (content.trim()) {
                    vultureResults += content + '\n\n';
                    console.log(`Found Vulture results in ${item}`);
                  }
                }
              } catch (error) {
                console.log(`Error reading Vulture ${item}: ${error.message}`);
              }
            }
          }
          
          // Check for merged safety-results.txt file
          const safetyFile = 'safety-results.txt';
          let safetyResults = '';
          
          if (fs.existsSync(safetyFile)) {
            try {
              safetyResults = fs.readFileSync(safetyFile, 'utf8');
              console.log('Found merged Safety results file');
            } catch (error) {
              console.log(`Error reading Safety file: ${error.message}`);
            }
          } else {
            // Fallback: look for individual result directories
            console.log('Merged Safety file not found, checking individual directories...');
            const items = fs.readdirSync('.').filter(item => item.startsWith('safety-results-'));
            
            for (const item of items) {
              try {
                const itemPath = path.join('.', item);
                const stat = fs.statSync(itemPath);
                
                if (stat.isDirectory()) {
                  const filePath = path.join(itemPath, 'safety-results.txt');
                  if (fs.existsSync(filePath)) {
                    const content = fs.readFileSync(filePath, 'utf8');
                    if (content.trim()) {
                      safetyResults += content + '\n\n';
                      console.log(`Found Safety results in ${item}`);
                    }
                  }
                } else if (stat.isFile() && item.endsWith('.txt')) {
                  const content = fs.readFileSync(itemPath, 'utf8');
                  if (content.trim()) {
                    safetyResults += content + '\n\n';
                    console.log(`Found Safety results in ${item}`);
                  }
                }
              } catch (error) {
                console.log(`Error reading Safety ${item}: ${error.message}`);
              }
            }
          }
          
          // Check for pyright results files (one per Python version)
          // Collect results per version, then deduplicate identical outputs
          let pyrightResults = '';
          const pyrightFiles = fs.readdirSync('.').filter(f => f.startsWith('pyright-results-') && f.endsWith('.txt'));
          
          // Map: content -> [versions]
          const pyrightByContent = new Map();
          
          if (pyrightFiles.length > 0) {
            for (const file of pyrightFiles) {
              try {
                const content = fs.readFileSync(file, 'utf8').trim();
                if (content) {
                  // Extract version from filename (e.g., pyright-results-3.9.txt -> 3.9)
                  const version = file.replace('pyright-results-', '').replace('.txt', '');
                  if (!pyrightByContent.has(content)) {
                    pyrightByContent.set(content, []);
                  }
                  pyrightByContent.get(content).push(version);
                  console.log(`Found Pyright results for Python ${version}`);
                }
              } catch (error) {
                console.log(`Error reading ${file}: ${error.message}`);
              }
            }
          } else {
            // Fallback: look for individual result directories
            console.log('No Pyright result files found, checking individual directories...');
            const items = fs.readdirSync('.').filter(item => item.startsWith('pyright-results-'));
            
            for (const item of items) {
              try {
                const itemPath = path.join('.', item);
                const stat = fs.statSync(itemPath);
                
                if (stat.isDirectory()) {
                  const dirFiles = fs.readdirSync(itemPath).filter(f => f.endsWith('.txt'));
                  for (const file of dirFiles) {
                    const filePath = path.join(itemPath, file);
                    const content = fs.readFileSync(filePath, 'utf8').trim();
                    if (content) {
                      const version = item.replace('pyright-results-', '');
                      if (!pyrightByContent.has(content)) {
                        pyrightByContent.set(content, []);
                      }
                      pyrightByContent.get(content).push(version);
                      console.log(`Found Pyright results in ${item}/${file}`);
                    }
                  }
                }
              } catch (error) {
                console.log(`Error reading Pyright ${item}: ${error.message}`);
              }
            }
          }
          
          // Build deduplicated pyright output
          for (const [content, versions] of pyrightByContent.entries()) {
            // Sort versions for consistent display
            versions.sort((a, b) => parseFloat(a) - parseFloat(b));
            if (versions.length === 1) {
              pyrightResults += `=== Python ${versions[0]} ===\n${content}\n\n`;
            } else {
              pyrightResults += `=== Python ${versions.join(', ')} (identical results) ===\n${content}\n\n`;
            }
          }

          // Check for ruff results files (one per Python version)
          // Collect results per version, then deduplicate identical outputs
          let ruffResults = '';
          const ruffFiles = fs.readdirSync('.').filter(f => f.startsWith('ruff-results-') && f.endsWith('.txt'));
          const ruffByContent = new Map();

          if (ruffFiles.length > 0) {
            for (const file of ruffFiles) {
              try {
                const content = fs.readFileSync(file, 'utf8').trim();
                if (content) {
                  const version = file.replace('ruff-results-', '').replace('.txt', '');
                  if (!ruffByContent.has(content)) {
                    ruffByContent.set(content, []);
                  }
                  ruffByContent.get(content).push(version);
                  console.log(`Found Ruff results for Python ${version}`);
                }
              } catch (error) {
                console.log(`Error reading ${file}: ${error.message}`);
              }
            }
          } else {
            console.log('No Ruff result files found, checking individual directories...');
            const items = fs.readdirSync('.').filter(item => item.startsWith('ruff-results-'));

            for (const item of items) {
              try {
                const itemPath = path.join('.', item);
                const stat = fs.statSync(itemPath);

                if (stat.isDirectory()) {
                  const dirFiles = fs.readdirSync(itemPath).filter(f => f.endsWith('.txt'));
                  for (const file of dirFiles) {
                    const filePath = path.join(itemPath, file);
                    const content = fs.readFileSync(filePath, 'utf8').trim();
                    if (content) {
                      const version = item.replace('ruff-results-', '');
                      if (!ruffByContent.has(content)) {
                        ruffByContent.set(content, []);
                      }
                      ruffByContent.get(content).push(version);
                      console.log(`Found Ruff results in ${item}/${file}`);
                    }
                  }
                }
              } catch (error) {
                console.log(`Error reading Ruff ${item}: ${error.message}`);
              }
            }
          }

          for (const [content, versions] of ruffByContent.entries()) {
            versions.sort((a, b) => parseFloat(a) - parseFloat(b));
            if (versions.length === 1) {
              ruffResults += `=== Python ${versions[0]} ===\n${content}\n\n`;
            } else {
              ruffResults += `=== Python ${versions.join(', ')} (identical results) ===\n${content}\n\n`;
            }
          }

          // Check for deprecation warnings (one per Python version)
          let deprecationResults = '';
          const deprecationFiles = fs.readdirSync('.').filter(f => f.startsWith('deprecation-warnings-') && f.endsWith('.txt'));
          const deprecationByContent = new Map();

          if (deprecationFiles.length > 0) {
            for (const file of deprecationFiles) {
              try {
                const content = fs.readFileSync(file, 'utf8').trim();
                if (content) {
                  const version = file.replace('deprecation-warnings-', '').replace('.txt', '');
                  if (!deprecationByContent.has(content)) {
                    deprecationByContent.set(content, []);
                  }
                  deprecationByContent.get(content).push(version);
                  console.log(`Found deprecation warnings for Python ${version}`);
                }
              } catch (error) {
                console.log(`Error reading ${file}: ${error.message}`);
              }
            }
          } else {
            console.log('No deprecation warning files found, checking individual directories...');
            const items = fs.readdirSync('.').filter(item => item.startsWith('deprecation-warnings-'));

            for (const item of items) {
              try {
                const itemPath = path.join('.', item);
                const stat = fs.statSync(itemPath);

                if (stat.isDirectory()) {
                  const dirFiles = fs.readdirSync(itemPath).filter(f => f.endsWith('.txt'));
                  for (const file of dirFiles) {
                    const filePath = path.join(itemPath, file);
                    const content = fs.readFileSync(filePath, 'utf8').trim();
                    if (content) {
                      const version = item.replace('deprecation-warnings-', '');
                      if (!deprecationByContent.has(content)) {
                        deprecationByContent.set(content, []);
                      }
                      deprecationByContent.get(content).push(version);
                      console.log(`Found deprecation warnings in ${item}/${file}`);
                    }
                  }
                }
              } catch (error) {
                console.log(`Error reading deprecation warnings ${item}: ${error.message}`);
              }
            }
          }

          for (const [content, versions] of deprecationByContent.entries()) {
            versions.sort((a, b) => parseFloat(a) - parseFloat(b));
            if (versions.length === 1) {
              deprecationResults += `=== Python ${versions[0]} ===\n${content}\n\n`;
            } else {
              deprecationResults += `=== Python ${versions.join(', ')} (identical results) ===\n${content}\n\n`;
            }
          }
          
          banditResults = banditResults.trim();
          vultureResults = vultureResults.trim();
          safetyResults = safetyResults.trim();
          pyrightResults = pyrightResults.trim();
          ruffResults = ruffResults.trim();
          deprecationResults = deprecationResults.trim();
          
          // Filter out manager warnings about test comments from Bandit results
          let cleanBanditResults = '';
          if (banditResults) {
            const lines = banditResults.split('\n');
            const filteredLines = lines.filter(line => !line.includes('[manager]\tWARNING\tTest in comment'));
            cleanBanditResults = filteredLines.join('\n').trim();
          }
          
          // Check if we have any issues to report
          const hasBanditIssues = cleanBanditResults && cleanBanditResults.includes('Issue: [');
          const hasVultureIssues = vultureResults && vultureResults.includes('(100% confidence)');
          const hasSafetyIssues = safetyResults && safetyResults.includes('Dependency vulnerabilities detected:');
          const hasPyrightIssues = pyrightResults && !pyrightResults.includes('0 errors') && pyrightResults.trim() !== '';
          const hasRuffIssues = ruffResults && !ruffResults.includes('All checks passed!') && ruffResults.trim() !== '';
          const hasDeprecationWarnings = deprecationResults && deprecationResults.trim() !== '';
          
          if (!hasBanditIssues && !hasVultureIssues && !hasSafetyIssues && !hasPyrightIssues && !hasRuffIssues && !hasDeprecationWarnings) {
            console.log('No security, dead code, dependency, type issues, lint issues, or deprecation warnings found, skipping PR comment.');
            return;
          }
          
          // Build the comment body
          let body = '## üîç Code Analysis Results\n\n';
          
          if (hasPyrightIssues) {
            body += '### üîç Pyright Type Checking\n\n```\n' + pyrightResults + '\n```\n\n';
          }

          if (hasRuffIssues) {
            body += '### üßπ Ruff Lint\n\n```\n' + ruffResults + '\n```\n\n';
          }

          if (hasDeprecationWarnings) {
            body += '### ‚ö†Ô∏è Deprecation Warnings (Runtime)\n\n```\n' + deprecationResults + '\n```\n\n';
          }
          
          if (hasBanditIssues) {
            body += '### üîí Bandit Security Analysis\n\n```\n' + cleanBanditResults + '\n```\n\n';
          }
          
          if (hasVultureIssues) {
            body += '### üßπ Dead Code Analysis (Vulture)\n\n```\n' + vultureResults + '\n```\n\n';
          }
          
          if (hasSafetyIssues) {
            body += '### üì¶ Dependency Security Analysis (Safety)\n\n```\n' + safetyResults + '\n```\n\n';
          }
          
          body += '*This comment was automatically generated by the CI pipeline.*';
          
          try {
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
            console.log('Successfully posted code analysis results to PR');
          } catch (error) {
            console.error(`Failed to post PR comment: ${error.message}`);
            throw error;
          }